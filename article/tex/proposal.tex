\section{Experimental Framework}\label{section:proposal}

In order to to execute the proposed study, the following framework
with three components was implemented. NEAT and the studied varients
were implemented as a C++ library. The bot that connects to BWAPI,
performs the learning and combat tasks, and logs the resulting data
was also implemented as a C++ project. The scripts for data analysis
were implemented as an R project. The source code and data files for
each of these components are available at the following repositories:
{\bf LIBRARYNAME\footnote{\url{https://github.com/uuuuu/nnnnn}}}, {\bf
  BOTNAME\footnote{\url{https://github.com/uuuuu/nnnnn}}}, and {\bf
  ANALYSISNAME\footnote{\url{https://github.com/uuuuu/nnnnn}}}

%NEToolKit\footnote{\url{https://github.com/CBenoit/NEToolKit}}
%Evolubot\footnote{\url{https://github.com/CBenoit/Evolubot}}.
%Evolubot_Analysis{\url{https://github.com/CBenoit/EvolubotAnalysis}}.

The four variants investigated in this study are as follows
\begin{itemize}
    \item \emph{Vanilla}. The default NEAT, as described in
      section~\ref{subsec:neat}. Each generation is evaluated using one
      game, where each unit uses the network of a different individual
      in the Population. The fitness of each individual is based on
      the performance of that particular unit.
    \item \emph{Cascade-NEAT}. The Cascade-NEAT variant, described in
      section~\ref{subsec:cascade-neat}. The evaluation procedure is
      the same as for Vanilla NEAT.
    \item \emph{Novelty Search with vanilla NEAT}. Here we use a
      different fitness function (described below) following the
      Novelty Search method described in
      section~\ref{subsec:novelty-search}. The evaluation procedure is
      the same as for Vanilla NEAT above.
    \item \emph{``Unified'' networks with vanilla NEAT}. In this
      variant, we modify the evaluation procedure. Only one individual
      is evaluated per game and, on each game, the entire squad has
      the same neural network. The fitness is calculated based on the
      performance of all individuals. For the sake of fairness, the
      number of generations is reduced proportionally in comparison
      with the above three variants.
\end{itemize}


\subsection{Neural Networks Inputs and Outputs}

The Neural Network used in our experimental framework has the
following inputs and outputs.

Inputs:
\begin{itemize}
    \item The cooldown of the ground weapon.
    \item The distance to the closest enemy;
    \item The number of enemies in sight;
    \item The distance to the closest allies;
    \item The numberof allies in sight;
    \item (Marines only) Whether the Unit has \emph{Stimpack} active or not.
\end{itemize}

Outputs:
\begin{itemize}
    \item {\bf Attack}: Attacks the weakest enemy in sight;
    \item {\bf Retreat}: Move away from enemies in sight;
    \item {\bf Spread out}: Move away from allies in sight;
    \item {\bf Gather}: Mote towards allies in sight;
    \item {\bf Use Stimpack}: For marines only.
\end{itemize}

The \emph{attack} action orders the unit to attack the weakest enemy
at fire range. If there are no enemies in fire range sight, the
unit move towards the closest visible enemy. Otherwise, it does nothing.

The \emph{retreat}, \emph{spread out} and \emph{gather} actions
calculate a weighted vector to decide the position that the unit is
ordered to move to. This vector is calculated based on the method used
by~\cite{Shantia11ConnectionistSC, Wender12ReinforcementMicroSC,
  Zhen13NeuroEvoSC}.

Our version differ slightly though. The weight of each unit to the
vector is proportional to their distance to the agent. In the case of
\emph{Retreat}, ally units get a significantly smaller weight than
enemy units, so that the agent avoid collision with allies while
moving away from enemies. For \emph{Spread Out}, only allies are
weighted. For \emph{Gather}, only allies are weighted and they have
negative weight.

\subsection{Fitness Specification}\label{subsec:fitness-specification}

In this study we consider that, during an actual game, the ability
to preserve's one's units is as important as the ability to defeat
enemy units. Therefore, we formulate a fitness function that
measures survival rates as well as victory rates.

For the Vanilla and Cascade variants, the fitness function is
given by:
\begin{equation}\label{eq:fitness_unit}
  (\text{damage\_dealt} \times A + \text{health} \times B +
  \text{survivors} \times C)^D,
\end{equation}
Where \emph{damage\_dealt} is the amount of damage caused to all
enemies, \emph{health} is the total remaining health of the unit, and
\emph{survivors} is the total remaining ally units, to promote
cooperation. $A, B, C,$ and $D$ are weight parameters (discussed in
the next section).

For the Unified variant, the fitness function is given by:
\begin{equation}\label{eq:fitness_group}
  (\text{damage\_dealt} \times A + \text{survivors} \times C)^D.
\end{equation}
Where the components are the same as in the previous equation.

Finally, for the Novelty variant, we use the difference in fitness as
the Novelty metric. Better alternative choices of Novelty metric are
discussed in section~\ref{section:conclusion}
